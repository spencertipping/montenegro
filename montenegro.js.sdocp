sdocp('montenegro.js.sdoc', 'Montenegro server library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nMontenegro extends Caterwaul (http://spencertipping.com/caterwaul) to operate in a node.js environment and provide REST web services. It provides asynchronous connectors, stream transformers,\nURL routing, and some other utilities that make non-blocking servers easier to develop.\n\n  caterwaul.\n\nNode.js variables and Montenegro reference.\nCaterwaul has a problem with node.js variables. Specifically, code that it compiles can\'t reach the \'require\' variable, which ends up being really important. To fix this, Montenegro binds that\nvariable within any compiled function by using a macro.\n\n   configuration(\'montenegro.core\',           function () {this.field(\'montenegro\', {require: require})}).\n  tconfiguration(\'std\', \'montenegro.require\', function () {this.configure(\'montenegro.core\').macro(qs[require],    let[ref = new this.ref(this.montenegro.require)] in fn_[ref])}).\n  tconfiguration(\'std\', \'montenegro.ref\',     function () {this.configure(\'montenegro.core\').macro(qs[montenegro], let[ref = new this.ref(this.montenegro)]         in fn_[ref])}).\n\nREST wrapper.\nMost applications do (or should) use a REST API for data management. Standard resources can be addressed by Montenegro clients using wrapper functions; this interface provides the server-side\nHTTP interface to make that happen. You can define a service with the http[] macro, or longhand with the \'montenegro.http.service()\' constructor.\n\n  Defining services.\n  The most obvious case is to provide a GET/POST service that is tied to a database (Montenegro doesn\'t use PUT or DELETE, though I may add them later). Here\'s what that looks like:\n\n  | var db = caterwaul.db.file(\'some-directory\');\n    var service = http[\'/people/_\'][get  = db($[1])(ok),\n                                    post = db($[1])(post_json())(ok)];\n    require(\'http\').createServer(fn[req, res][service(req, res)]).listen(8080);\n\n  Equivalently, you can use the value-space constructor to get a first-class path (which may be more useful if you want to create a bunch of services with similar behaviors):\n\n  | var service = montenegro.http.service(\'/people/_\',\n                    {get: fn[context][db(context.$[1])(context.ok)],\n                    post: fn[context][db(context.$[1])(context.post_json())(context.ok)]});\n\n  You get these variables within the context of a service definition:\n\n  | 1. The URL match-group variable, $ -- the value returned from the constructed regexp\'s .exec() method. Each \'_\' in the URL is a wildcard.\n    2. ok(): a function that returns 200 OK with the JSON object given.\n    3. error(): a function that replies with 500 and a string message if you give it one.\n    4. not_found(): a function that replies with 404 and a string message if you give it one.\n    5. post_data and post_json() (for POSTs) -- a variable and a function that return the original string POST-data and JSON-decoded POST-data, respectively.\n    6. request: the original HTTP request object.\n    7. response: the original HTTP response object.\n\n  You can compose services by calling each one in succession:\n\n  | var s1 = http[...][...], s2 = http[...][...];\n    require(\'http\').createServer(fn[req, res][s1(req, res), s2(req, res)]).listen(8080);\n\n  Because writing this code gets old quickly, you can use the variadic service-composition function:\n\n  | var s1 = http[...][...], s2 = http[...][...];\n    var service = montenegro.http.compose(s1, s2);\n    require(\'http\').createServer(service).listen(8080);\n\n    tconfiguration(\'std seq error\', \'montenegro.class.http\', function () {\n      this.configure(\'montenegro.core\').montenegro.http = {compose: fn_[let[as = sa<< arguments] in fn[request, response][x(request, response) <se< as]]};\n      this.montenegro.http.service(path, handlers) =\n        let*[path_pattern = new RegExp(\'^#{path.replace(/_/g, "([^/]+)")}/?$\')] in\n        fn[request, response][let[pieces = []][request.on(\'data\', fn[piece][pieces.push(piece)]), request.on(\'end\', cc(pieces.join(\'\')))],\n          where*[cc(data)          = match && handlers[method] && handlers[method](context_for(data)), match = path_pattern.exec(request.url), method = request.method.toLowerCase(),\n                 context_for(data) = {request: request, response: response, post_data: data, post_json: fn_[JSON.parse(data)], $: match,\n                                           ok: fn[json]  [response.writeHead(200, {\'content-type\': \'application/json\'}), response.end(JSON.stringify(json))],\n                                        error: fn[reason][response.writeHead(500, {\'content-type\': \'text/plain\'}), response.end(reason)],\n                                    not_found: fn[reason][response.writeHead(404, {\'content-type\': \'text/plain\'}), response.end(reason)]}]]}).\n\n    tconfiguration(\'std montenegro.ref\', \'montenegro.http\', function () {\n      this.configure(\'montenegro.class.http\').rmacro(qs[http[_][_]],\n        fn[path, methods][qs[_service(_path, _handlers)].replace({_service: service, _path: path, _handlers: handlers}),\n          where*[service   = new caterwaul.ref(montenegro.http.service),\n                 handlers  = new caterwaul.ref(let[result = {}][methods.flatten(\',\').each(fn[x][result[x.name] = x.value]), result]),\n                 method(m) = (match ? {name: match[0].as_escaped_string(), value: context(match[1])} : error.fail[new Error(\'montenegro.http: invalid service: #{m.serialize()}\')],\n                   where[match         = m.match(qs[_ = _]),\n                         context(tree) = qs[fn[context][_tree, where[$ = context.$, ok = context.ok, error = context.error, not_found = context.not_found, post_data = context.post_data,\n                                                                     post_json = context.post_json, request = context.request, response = context.response]]].replace({_tree: tree})])]])}).\n\nFinal configuration.\nThis configuration bundles all of the configurations together.\n\n  configuration(\'montenegro\', function () {this.configure(\'montenegro.require montenegro.ref montenegro.http\')});\n');