sdocp('montenegro.client.js.sdoc', 'Montenegro client-side bindings | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nMontenegro works with jQuery to add structure to user interfaces and define useful shorthands for common cases. It also provides a Javascript markup language that you can use to build\ninterfaces instead of going the HTML route. For logic-heavy applications this may make more sense than separating the layout.\n\nCore extension.\nThis just takes care of initializing the montenegro object on Caterwaul. We also close over the jQuery object so that the user can set noConflict() later on without disrupting the HTML\nconstructors. You can also replace this jQuery function with a different one, maybe to trace the calls or some such.\n\n  caterwaul.configuration(\'montenegro.core\', function () {this.shallow(\'montenegro\', {$: jQuery})}).\n\nJQuery extension methods.\nThese are used throughout Montenegro. se() is used to create side-effects on elements, which can be useful in the middle of long chains (this works better with the precedence than /se[] does).\nup() takes either a selector or a number. If you give it a selector, it grabs the nearest matching parent; if you give it a number, it traverses up that many parents.\n\nThe nearest() method lets you do approximate matching. For example, suppose you have this setup:\n\n| div.foo(div > textarea, div > button.save)\n\nIf you want the save button to see the textarea (e.g. from inside a click handler), the obvious solution is $(this).parent().find(\'textarea\'). However, that\'s a lot of work and doesn\'t scale\nwell. Better is to say $(this).nearest(\'textarea\'). Note that it doesn\'t actually return just the single nearest one. It just goes up until it starts finding textareas. Note that .nearest() is\nO(n^2) and average-case n log n in the number of nodes in the document.\n\nThe cval() method returns and then clears the value of a component. If you give it a parameter, the value will be cleared to that value rather than set to the empty string.\n\n  tconfiguration(\'std seq\', \'montenegro.methods\', function () {this.configure(\'montenegro.core\').montenegro.$.fn /se[\n    _.se(f)      = this /se[f.call(_, _)],\n    _.up(s)      = s instanceof Number ? s ? this.parent().up(s - 1) : this : this.closest(s),\n    _.cval(nv)   = l[v = this.val()] in this.val(nv || \'\') /re[v],\n    _.mappend()  = this /se.t[seq[~arguments *![_ instanceof Array ? seq[~_ *![t.mappend(_)]] : t.append(_ instanceof String ? document.createTextNode(_) : _), unless[_ == null]]]],\n    _.nearest(s) = this.length ? this.find(s) /re[_.length ? _ : this.parent().nearest(s)] : $([])]}).\n\n  Event extensions.\n  Some events are common enough that it\'s useful to have a handler for them. Hitting the enter key is one of those. Another is getting a link to have a click action and look active, but not\n  actually go anywhere.\n\n    tconfiguration(\'std\', \'montenegro.events\', function () {this.configure(\'montenegro.core\').montenegro.$.fn /se[\n      _.enter(f)     = this.keyup(fn[e][e.which === 13 && f.call(this, e)]),\n      _.clickable(f) = this.attr(\'href\', \'javascript:void(0)\').click(f)]}).\n\nRPC tunneling.\nYou can connect to a server endpoint with a CPS-converted proxy function. You can also send opaque references to the server (presumably so that it can send them back). Here\'s an example of\npassing a DOM node:\n\n| var identity = montenegro.rpc(\'/identity-function\');\n  var body     = $(\'body\');\n  identity(montenegro.rpc.ref(body), fn[result][montenegro.rpc.ref(result).append(\'Got the body element back\')]);\n  // alternatively:\n  l/cps[result <- identity(montenegro.rpc.ref(dom_node), _)][montenegro.rpc.ref(result).append(\'Got the body element back\')];\n\nAssuming that the server replies with the data it was given, this will append some text to the document body when the server replies. The mechanism for this is actually really simple;\nmontenegro.rpc.ref() just assigns a new gensym to each value you alias; that string goes to the server and is later resolved back into the client-side value. (This is why the server won\'t be\nable to do anything useful with the value.) Montenegro automatically garbage-collects the reference table by deallocating a reference when you dereference it. (So you can\'t dereference\nsomething more than once; if you do this it will create a new reference instead.)\n\n  Example: Building a chat client.\n  In montenegro.server.js.sdoc there\'s an example of a broadcast chat server. Here\'s the corresponding client code and some DOM nodes to make it work:\n\n  | var send = caterwaul.montenegro.rpc(\'/chat/send\');\n    caterwaul.montenegro.rpc(\'/chat\')(fn[message][$(\'.log\').append(html[div.message(message)]), this()]);\n    $(\'body\').append(html[div(div.log, button(\'Send\'), input]));         // This just builds the UI. You could also do this with regular HTML.\n    l/cps[_ <- $(\'button\').click(_)][send($(\'#input\').val())];\n\n  The \'this()\' invocation inside the callback is used when you want to send something back and reuse the callback function. I\'m using it here to avoid having to refer to the callback function\n  in a first-class way (which would normally be necessary to set the cycle up again).\n\n    tconfiguration(\'std seq\', \'montenegro.rpc\', function () {\n      this.configure(\'montenegro.core\').montenegro /se[\n        _.rpc(url)() = l[as = seq[~arguments]][l*[callback = as.length && as[as.length - 1] /re[_.constructor === Function && as.pop()]] in\n                                                 $.ajax({url: url, type: \'POST\', contentType: \'application/json\', data: JSON.stringify(as.slice()),\n                                                     success: fn[reply][callback && callback.apply(fn_[_.rpc(url).apply(null, seq[~arguments].slice().concat([callback]))], reply)]})]]}).\n\nDOM construction.\nYou can build elements using a CSS-selector-style syntax. (Alternatively, you can provide an element in the markup; if you do it this way, the template element\'s ID should match the model\nname.) So, for example, suppose we\'re modeling a person with a name and e-mail address. Here\'s what the markup might look like in HTML:\n\n| <div id=\'person\' class=\'person\'>\n    <label for=\'name1\'>Name:</label>\n    <input id=\'name1\' class=\'name nonempty\' />\n    <label for=\'email1\'>Email:</label>\n    <input id=\'email1\' class=\'email\' />\n    <a class=\'facebook\' href=\'http://facebook.com/someone\'>A Facebook Page</a>\n  </div>\n\n| html[div.person(input.name.nonempty, input.email, a.facebook /attr(\'href\', \'http://facebook.com/someone\') > \'A Facebook Page\')]\n\nNote that you can\'t use hyphens in the class names in Javascript, but if you type underscores they\'ll be converted into dashes. For example:\n\n| html[div.first_name]          // becomes <div class=\'first-name\'></div>\n\n  Automation and event handlers.\n  You can get the jQuery shell for an element by using the \'/\' operator. The right-hand side is an invocation on the jQuery shell; for example:\n\n  | $(\'<a>\').addClass(\'foo\').click(fn_[...]).mouseover(fn_[...])\n    // can be written as:\n    html[a.foo /click(fn_[...]).mouseover(fn_[...])]\n\n  Anything after a \'/\' for an element is not considered to be HTML, so you\'ll have to use another html[] if you want to create elements to pass into a jQuery function. For example:\n\n  | html[a.foo /append(span(\'some text\'))]              // won\'t do what you want\n    html[a.foo /append(html[span(\'some text\')])]        // this is the right way to do it\n    html[a.foo > span(\'some text\')]                     // even better\n\n  Evaluating subexpressions.\n  Going back to the person example, suppose you have a list of people that you want to insert into a div. Here\'s what that looks like:\n\n  | var people = seq[...];\n    var person = fn[p][html[div.person(input.name.nonempty /val(p.name))]];\n    var ui     = html[div.people(people.map(person), button.save(\'Save\'), button.cancel(\'Cancel\'))];\n\n  Here, the expression \'people.map(person)\' gets evaluated as a Javascript expression rather than as markup. Montenegro knows to do this because \'people\' isn\'t one of the HTML elements it\n  knows about. Javascript expressions should return strings, sequences, arrays, or jQuery objects. Strings get promoted into text nodes, so you don\'t have to worry about HTML escaping.\n\n  Mapping.\n  You can map an element through a function using the \'%\' shorthand. For example:\n\n  | var nonempty = fn_[this.instavalidate(/^.+$/)];\n    var ui = html[div(input.name %nonempty, input.title %nonempty)]\n\n  This isn\'t quite the same thing as side-effecting. Using the map shorthand replaces the element with whatever your map function returns, which may or may not be desirable.\n\n  Note that tempting as it is, you can\'t say this:\n\n  | html[div((input.name, input.title) %nonempty)]       // can\'t do this, even though it would be awesome\n\n  I considered adding a distributive property, but Javascript\'s syntax is restrictive enough that I don\'t think it makes sense. It also makes you think too hard about your markup, which isn\'t\n  a good thing. The markup should be simple and local, and your modifier functions should be short enough to type several times. (This can be achieved by using a let-binding or similar.)\n\n  Evaluation contexts.\n  Containment can be specified either as div(x) or by div > x. If you want \'x\' to be evaluated as Javascript code rather than HTML, you can use >=, for instance div >= x. (Think of <% vs. <%=\n  in ERB or ASP.) Specifying multiple children is possible too; you use div >= [x, y, z]. (Using div >= (x, y, z) will evaluate (x, y, z) as JS, which returns just z.)\n\n  Note that because > and >= are left-associative, a > b > c will add b and c to a rather than adding c to b, then b to a.\n\n  Context inference.\n  There\'s a little bit of guessing that goes on about what\'s what. Usually the guesser gets things right, but there are some older HTML nodes that it doesn\'t detect. For example:\n\n  | html[div.foo > people.map(person)]          // div.foo is an element, people.map(person) is a function call -- its return value will be appended to the div\n    html[a.code > b.code > \'foo\']               // a.code is a link with class \'code\' that contains the Javascript value \'b.code\' and the text \'foo\'\n\n  The complete list is in caterwaul.montenegro.dom.elements; setting additional keys in this hash to truthy values causes those identifiers to be treated as valid HTML elements.\n\n  Code transparency.\n  By default the code that Montenegro generates isn\'t transparent; that is, it has hard syntactic bindings (gensyms) and can\'t be transported with toString(). However, there are cases where\n  you want to be able to transport some code. To do this, you need to configure Montenegro using montenegro.dom.indirected-references. After that the HTML shell code will refer only to the\n  \'document\' and \'jQuery\' globals, but not to other elements. This makes it safe to send between clients using Function.toString() or similar. (Though you\'ll probably want to macroexpand it\n  beforehand unless it uses the sequence library.)\n\n    configuration(\'montenegro.dom.indirected-references\', function () {this.montenegro.indirected_references = true}).\n    tconfiguration(\'std seq continuation opt\', \'montenegro.dom\', function () {\n      this.configure(\'montenegro.core montenegro.methods\').montenegro /se.m[m.indirected_references = false, m.dom = l[$ = m.$] in caterwaul.global().clone() /se[\n        this.rmacro(qs[html[_]], _.macroexpand),\n\n        _.elements = caterwaul.util.qw(\'html head body meta script style link title div a span input button textarea option select form label iframe blockquote code caption \' +\n                                       \'table tbody tr td th thead tfoot img h1 h2 h3 h4 h5 h6 li ol ul noscript p pre samp sub sup var canvas audio video\') /re[seq[!(~_ *[[_, _]])]],\n\n        l*[ref(x) = new caterwaul.ref(x), expand = _.macroexpand, is_an_element(tree) = _.elements[tree.data] || tree[0] && is_an_element(tree[0])] in\n\n        _.macro /se[_(qs[_], fn[x][e ? qs[_$(_document.createElement(_tag))].replace(l[i = m.indirected_references] in\n                      {_$: i ? qs[jQuery] : ref($), _document: qs[document], _tag: \'"#{e}"\'}) : x, where[e = is_an_element(x)]]),\n\n                    _(qs[_(_)], append), _(qs[_[_]], append_eval), _(qs[_ > _], append), _(qs[_ >= _], append_eval),\n                    where[append(t1, t2)      = is_an_element(t1) && qs[_e.mappend(_c)].replace({_e: expand(t1), _c: expand(t2)}),\n                          append_eval(t1, t2) = is_an_element(t1) && qs[_e.mappend(_c)].replace({_e: expand(t1), _c: t2})],\n\n                    _(qs[[_]],  fn     [t][qs[[_e]].replace({_e: expand(t)})]),\n                    _(qs[_ %_], fn[t1, t2][qs[_f(_e)].replace({_e: expand(t1), _f: t2})]),\n                    _(qs[_._],  fn[t1, t2][qs[_e.addClass(_c)].replace({_e: expand(t1), _c: \'"#{t2.data.replace(/_/g, "-")}"\'}), when[is_an_element(t1)]]),\n                    _(qs[_ /_], fn[t1, t2][qs[_e._f].replace({_e: expand(t1), _f: t2})]),\n                    _(qs[_, _], fn[t1, t2][qs[_1, _2].replace({_1: expand(t1), _2: expand(t2)})])]]]}).\n\nFinal configuration.\nThis one loads all of the others (though it lets you specify whether you want indirected references or not).\n\n  configuration(\'montenegro\', function () {this.configure(\'montenegro.events montenegro.methods montenegro.rpc montenegro.dom\')});\n');