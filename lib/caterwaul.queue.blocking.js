// Asynchronous blocking queue | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module provides a CPS-converted blocking queue, as is appropriate for something like filehandle allocation for a node.js server. The basic idea is that you want to create a request for
// some resource, then service that request, and finally free the resource; but you want to do this in a non-blocking way that prevents starvation. Optimistic locking doesn't provide this
// guarantee, so I'm writing a blocking queue to do it.

// Interface.
// Queues are created using the caterwaul.queue.blocking() function, which takes an integer for the size and an optional hash. Once you have a queue:

// | var queue = caterwaul.queue.blocking(10);

// You can make requests by invoking it on a callback:

// | queue(function (free) {
//     // Do stuff here
//     nonblocking_call(function (...) {
//       // Free the resource:
//       free();
//     });
//   });

//   Options.
//   Right now the only option supported is 'empty', which is called when the blocking queue's last item is removed. For example:

//   | caterwaul.queue.blocking(10, {empty: fn_[console.log('Empty queue!')]});

caterwaul.tconfiguration('std', 'queue.blocking', function () {
  (this.queue || this.shallow('queue', {}).queue).blocking(n, options) =
  let*[used = 0, waiting = [], deallocate() = waiting.length ? waiting.shift()(deallocate) : --used || options /se[_ && _.empty /se[_ && _()]]] in
  fn[cc][used < n ? cc(deallocate) /se[++used] : waiting.push(cc)];
});

// Generated by SDoc 
