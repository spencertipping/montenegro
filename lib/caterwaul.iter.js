// Iteration macros | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// These macros enable low-level iteration patterns from expression context. They're basically just syntactic abstractions over different types of for-loops; they aren't anything particularly
// high-level such as map or filter. (Those are/will be in the 'seq' library.) For optimized versions of some of these functions (e.g. unrolling), see the 'opt' module.

caterwaul.tconfiguration('std', 'iter', function () {
  this.rmacro(qs[iter.until[_][_]],   fn[condition, body]       [with_gensyms[condition][qg[function () {var condition; while (! (condition = qg[_condition])) {_body}; return condition}].call(this)].
                                                                  replace({_condition: condition, _body: body})]).
       rmacro(qs[iter.keys[_, _][_]], fn[variable, object, body][with_gensyms[object][qg[function (object) {for (var _variable in object) {_body}; return _object}].call(this, _object)].
                                                                  replace({_variable: variable, _body: body, _object: object})]).
       rmacro(qs[iter.n[_, _][_]],    fn[variable, limit, body] [with_gensyms[limit][qg[function (limit) {for (var _i = 0; _i < limit; ++_i) {_body}; return _limit}].call(this, _limit)].
                                                                  replace({_i: variable, _body: body, _limit: limit})])});

// Generated by SDoc 
