// Error handling macros | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// JavaScript's error handling is clunky to use, especially from inside an expression context. These macros abstract that away and let you handle errors in various ways. The simplest macro is
// probably error.quietly[], which silently ignores any errors. (It just returns false instead of whatever the expression would have returned.) Slightly more complex is error.safely[][], which
// takes two forms. The first is evaluated, and the result returned if there are no errors. If there is an error, then the second is evaluated in a context where 'error' is bound to the error
// object, and that result is returned.

// Also provided is an expression-mode throw, which lets you throw errors without returning to statement syntax. This is written error.fail[x], where x is the expression to be thrown. (JavaScript
// doesn't let you use the word 'throw', so an alternative word was needed.)

caterwaul.tconfiguration('std', 'error', function () {
  this.rmacro(qs[error.safely[_][_]], fn[expression, handler][qs[qg[function () {try {return _body} catch (error) {return _handler}}].call(this)].replace({_body: expression, _handler: handler})]).
       rmacro(qs[error.quietly[_]],   fn[expression]         [qs[qg[function () {try {return _body} catch (error) {return false}}].   call(this)].replace({_body: expression})]).
       rmacro(qs[error.fail[_]],      fn[expression]         [qs[qg[function () {throw _error}].call(this)].replace({_error: expression})])});

// Generated by SDoc 
