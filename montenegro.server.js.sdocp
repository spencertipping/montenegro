sdocp('montenegro.server.js.sdoc', 'Montenegro server library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nMontenegro extends Caterwaul (http://spencertipping.com/caterwaul) to operate in a node.js environment and provide an RPC endpoint.\n\n  caterwaul.\n\nNode.js variables and Montenegro reference.\nCaterwaul has a problem with node.js variables. Specifically, code that it compiles can\'t reach the \'require\' variable, which ends up being really important. To fix this, Montenegro binds that\nvariable within any compiled function by using a macro.\n\n   configuration(\'montenegro.core\', function () {this.shallow(\'montenegro\', {require: require})}).\n\nURL router.\nMontenegro gives you a quick proxy function to route requests based on URL patterns. This makes a suitable server if you want to promote it into one (and in fact it is the function you get\nback when you create a new server). Configuration is done like this:\n\n| var router = montenegro.route.url();\n  router.on(\'/foo\', \'GET\', fn[request, response][response /se[_.writeHead(200), _.end(\'bar\')]]);\n  router.not_found(request, response) = response /se[_.writeHead(404), _.end(\'Bummer dude, not found\')];\n\nBecause routers provide the same interface they accept, you can nest them and create proxies.\n\n  tconfiguration(\'std seq\', \'montenegro.route.url\', function () {\n    this.configure(\'montenegro.core\').montenegro /se[(_.route = _.route || {}) /se[\n      _.url() = result /se[_.handlers                     = seq[~[]],\n                           _.on(pattern, method, handler) = this /se[_.handlers.push({url: pattern, method: method, handler: handler})],\n                           _.not_found(request, response) = response /se[_.writeHead(404), _.end(\'#{request.url} was not found.\')],\n\n                           _.handler_for(url, method)     = seq[this.handlers %[(_.url.test ? _.url.test(url) : _.url === url) && _.method === method] *[_.handler]][0],\n                           _.route(request, response)     = this /se[(_.handler_for(request.url, request.method) || _.not_found).call(_, request, response)]]],\n                where*[result(request, response) = result.route(request, response)]]}).\n\nServer construction.\nYou construct a Montenegro server instance by calling montenegro.server(port). The server starts running immediately. Each server has an internal routing table that maps URL patterns to\nrequest handlers. (A request handler is just a function that Node\'s createServer would accept.)\n\n  tconfiguration(\'std seq\', \'montenegro.server\', function () {\n    let[require = this.configure(\'montenegro.core\').montenegro.require] in this.configure(\'montenegro.route.url\').montenegro /se[\n      _.server(port)      = caterwaul.util.merge(_.route.url(), _.server.extensions) /se[require(\'http\').createServer(_).listen(port || 8080, \'0.0.0.0\')],\n      _.server.extensions = {}]}).\n\nTrivial HTML construction.\nThis gives you a quick way to throw a page together. The key here is that you write a function that will end up being executed on the client-side when jQuery loads. For example, to say hello\nworld:\n\n| response /se[_.writeHead(200, {\'content-type\': \'text/html\'}),\n               _.end(montenegro.html(fn_[$(\'body\').append( html<< h1(\'Hello world!\'))]))];\n\nThis builds a client page that loads caterwaul.all.js, montenegro.client.js, and jQuery. By default, caterwaul.all.js and montenegro.jquery.js come from my webserver (which sometimes is down),\nbut you can change where it finds these scripts by setting _.html.script_path and _.html.jquery_path.\n\n  tconfiguration(\'std\', \'montenegro.html\', function () {\n    this.configure(\'montenegro.core\').montenegro /se[\n      _.html(f) = let*[html_header()       = let[s(src) = \'<script src="#{src}"></script>\'] in\n                                             \'<!doctype html><html><head>#{s(_.html.jquery_path)}#{s(_.html.caterwaul_path)}#{s(_.html.montenegro_path)}\',\n                       wrap_initializer(s) = \'<script>$(caterwaul.clone("std opt continuation seq montenegro")(#{s}))</script>\',\n                       html_footer()       = \'</head><body></body></html>\'] in\n                  html_header() + wrap_initializer(f.toString()) + html_footer(),\n\n      _.html /se[_.caterwaul_path  = \'http://spencertipping.com/caterwaul/caterwaul.all.js\',\n                 _.montenegro_path = \'http://spencertipping.com/montenegro/montenegro.client.js\',\n                 _.jquery_path     = \'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4\']]}).\n\nRPC endpoints.\nYou can create an RPC service on a URL. The RPC endpoint wraps the function in a CPS-converted HTTP request/response proxy that listens for POST requests on a given URL, expects a JSON array\nin the body, and converts the body into a list of parameters for the function you specify. Your function can access the reply continuation by either returning normally or invoking \'this\' on\nthe reply object.\n\nAll listeners are CPS-converted, so you can have coroutine-based communication between the client and server. For example, this is a broadcast chat server (which relies on singly re-entrant\ncontinuations for replies, if you want to think about it as a regular procedure call):\n\n| var chat_service = montenegro.server(8080);\n  var clients = seq[~[]];\n  chat_service.rpc(\'/chat\',      fn_[clients.push(this)]);\n  chat_service.rpc(\'/chat/send\', fn[message][seq[clients *![_(message)], clients = ~[]], this(\'OK\')]);\n\nThe client code for this example is in montenegro.client.js.sdoc.\n\nRPC services can provide documentation. This is an optional second parameter, e.g:\n\n| chat_service.rpc(\'/chat\', \'Clients should long-loop this URL to be notified of messages that are sent.\', fn_[...]);\n\nAny clients who GET the URL will be served the documentation string as plain text. If you don\'t specify any documentation, GET requests will be sent a generic \'there\'s a service here, but no\ndocumentation for it\' message as plain text. The service will also send potentially useful diagnostic messages with 400 error codes if you\'re using it incorrectly.\n\n  tconfiguration(\'std continuation\', \'montenegro.server.rpc\', function () {\n    let*[json_from(request, rpc)(cc) = request /se[_.on(\'data\', pieces/mb/push), _.on(\'end\', fn_[unwind_protect[rpc.error(e)][cc(JSON.parse(pieces.join(\'\')))]]), where[pieces = []]],\n         json_to  (response)()  = let[as = Array.prototype.slice.call(arguments)] in response /se[_.writeHead(200, {\'content-type\': \'application/json\'}), _.end(JSON.stringify(as))],\n         error_to (response)(e) = response /se[_.writeHead(400, {\'content-type\': \'text/plain\'}), _.end(e.toString())],\n\n         install_service(url, doc, fn, rpc) = this /se[_.on(url, \'POST\', fn[req, res][json_from(req, rpc)(fn[json][fn.apply(json_to(res), json)])]),\n                                                       _.on(url, \'GET\',  fn[req, res][res /se[_.writeHead(200, {\'content-type\': \'text/plain\'}), _.end(doc)]])],\n\n         install_test_page(url, rpc) = this /se[_.on(\'#{url}/test\', \'GET\', fn[req, res][res /se[_.writeHead(200, {\'content-type\': \'text/html\'}), _.end(rpc.testpage())]])],\n\n         html = this.configure(\'montenegro.html\').montenegro.html] in\n\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se[\n      _.rpc(url, _documentation, _fn) = (install_service.call(this, url, documentation, fn, _.rpc), install_test_page.call(this, url, _.rpc),\n                                         where[documentation = _fn ? _documentation : \'#{url} service (no documentation available)\', fn = _fn || _documentation]),\n\n  Error trapping.\n  If an error occurs, the client receives the toString() produced by the error object and a stack trace is logged to the console. However, you may want to do something different. If you do,\n  change montenegro.server.rpc.error(e).\n\n      _.rpc.error(e) = e /se[console.log(_)],\n\n  Test pages.\n  If you use the server as shown above, you\'ll get a test page for each RPC endpoint. For example, the test page for the \'/chat\' URL is \'/chat/test\'. You can navigate to this page and send\n  requests to the RPC to verify that it\'s working correctly. This is enabled in production-mode as well as development mode; it\'s my attempt to encode Kerckhoffs\' principle\n  (http://en.wikipedia.org/wiki/Kerckhoffs\'_principle) into the framework to prevent bad security decisions.\n\n      _.rpc.testpage() = html(fn_[$(\'body\').append( html<< h1(\'Test page\'))])]}).\n\nHTML server configuration.\nYou can send HTML pages to the client by writing initialization functions. To send a hello world page, for example:\n\n| montenegro.server(8080).html(\'/hello\', fn_[$(\'body\').append( html<< h1(\'Hello world!\'))]);\n\n  tconfiguration(\'std\', \'montenegro.server.html\', function () {\n    let[html = this.configure(\'montenegro.html\').montenegro.html] in\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se[\n      _.html(url, f) = let[s = html(f)] in this /se[_.on(url, \'GET\', fn[req, res][res /se[_.writeHead(200, {\'content-type\': \'text/html\'}), _.end(s)]])]]}).\n\nFinal configuration.\nThis configuration bundles all of the configurations together.\n\n  configuration(\'montenegro\', function () {this.configure(\'montenegro.html montenegro.route.url montenegro.server montenegro.server.rpc montenegro.server.html\')});\n');