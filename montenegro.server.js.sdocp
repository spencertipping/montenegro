sdocp('montenegro.server.js.sdoc', 'Montenegro server library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nMontenegro extends Caterwaul (http://spencertipping.com/caterwaul) to operate in a node.js environment and provide an RPC endpoint.\n\n  caterwaul.\n\nNode.js variables and Montenegro reference.\nCaterwaul has a problem with node.js variables. Specifically, code that it compiles can\'t reach the \'require\' variable, which ends up being really important. To fix this, Montenegro binds that\nvariable within any compiled function by using a macro.\n\n   configuration(\'montenegro.core\', function () {this.shallow(\'montenegro\', {require: require})}).\n\nGlobal error handling.\nThis installs a more sensible handler than the default \'die-on-error\' strategy that Node uses. It logs any errors to the console and otherwise continues running normally.\n\n  tconfiguration(\'std\', \'montenegro.global-error\', function () {process.on(\'uncaughtException\', console/mb/log)}).\n\nURL router.\nMontenegro gives you a quick proxy function to route requests based on URL patterns. This makes a suitable server if you want to promote it into one (and in fact it is the function you get\nback when you create a new server). Configuration is done like this:\n\n| var router = montenegro.route.url();\n  router.on(\'/foo\', \'GET\', fn[request, response][response /se[_.writeHead(200), _.end(\'bar\')]]);\n  router.not_found(request, response) = response /se[_.writeHead(404), _.end(\'Bummer dude, not found\')];\n\nBecause routers provide the same interface they accept, you can nest them and create proxies. The last matching pattern is the one that handles the URL, so you can always refine URL matches\n(or override them) by adding new on() handlers.\n\nEach service built with this interface exposes a list of methods. You can disable it by overriding the /services URL, but if exposing the request handlers is a security flaw then there is\nprobably a larger problem with the design of the application.\n\n  tconfiguration(\'std seq\', \'montenegro.route.url\', function () {\n    this.configure(\'montenegro.core\').montenegro /se[(_.route = _.route || {}) /se[\n      _.url() = result /se[_.handlers                     = seq[~[]],\n                           _.on(pattern, method, handler) = this /se[_.handlers.push({url: pattern, method: method, handler: handler})],\n                           _.not_found(request, response) = response /se[_.writeHead(404), _.end(\'#{request.url} was not found.\')],\n\n                           _.on(\'/services\', \'GET\', _.service_listing(req, res) = res /se.r[r.writeHead(200), r.end(seq[_.handlers *[\'#{_.url} (#{_.method})\']].join(\'\\n\'))]),\n\n                           _.handler_for(url, method)     = seq[this.handlers %[(_.url.test ? _.url.test(url) : _.url === url) && (! _.method || _.method === method)] *[_.handler]]\n                                                            /re[_[_.length - 1]],\n                           _.route(request, response)     = this /se[(_.handler_for(request.url, request.method) || _.not_found).call(_, request, response)]]],\n                where*[result(request, response) = result.route(request, response)]]}).\n\nServer construction.\nYou construct a Montenegro server instance by calling montenegro.server(port). The server starts running immediately. Each server has an internal routing table that maps URL patterns to\nrequest handlers. (A request handler is just a function that Node\'s createServer would accept.)\n\n  tconfiguration(\'std seq\', \'montenegro.server\', function () {\n    let[require = this.configure(\'montenegro.core\').montenegro.require] in this.configure(\'montenegro.route.url\').montenegro /se[\n      _.server(port)      = caterwaul.util.merge(_.route.url(), _.server.extensions) /se[require(\'http\').createServer(_).listen(port || 8080, \'0.0.0.0\')],\n      _.server.extensions = {}]}).\n\nTrivial HTML construction.\nThis gives you a quick way to throw a page together. The key here is that you quote a syntax tree that will end up being executed on the client-side when jQuery loads. For example, to say\nhello world:\n\n| response /se[_.writeHead(200, {\'content-type\': \'text/html\'}),\n               _.end(montenegro.html(qs[$(\'body\').append(html[h1(\'Hello world!\')])]))];\n\nThis builds a client page that loads caterwaul.all.js, montenegro.client.js, and jQuery. By default, caterwaul.all.js and montenegro.jquery.js come from my webserver (which sometimes is down),\nbut you can change where it requests these scripts by setting _.html.caterwaul_path, _.html.montenegro_path, and _.html.jquery_path.\n\n  tconfiguration(\'std\', \'montenegro.html\', function () {\n    this.configure(\'montenegro.core\').montenegro /se[\n      _.html(t) = let*[html_header()       = let[s(src) = \'<script src="#{src}"></script>\'] in\n                                             \'<!doctype html><html><head>#{s(_.html.jquery_path)}#{s(_.html.caterwaul_path)}#{s(_.html.montenegro_path)}\',\n                       wrap_initializer(s) = \'<script>$(caterwaul.clone("std opt continuation seq montenegro")(#{s}))</script>\',\n                       html_footer()       = \'</head><body></body></html>\'] in\n                  html_header() + wrap_initializer(qs[function () {return _t}].replace({_t: t}).serialize()) + html_footer(),\n\n      _.html /se[_.caterwaul_path  = \'http://spencertipping.com/caterwaul/caterwaul.all.js\',\n                 _.montenegro_path = \'http://spencertipping.com/montenegro/montenegro.client.js\',\n                 _.jquery_path     = \'http://spencertipping.com/jquery-patched/jquery.st.js\']]}).\n\nRPC endpoints.\nYou can create an RPC service on a URL. The RPC endpoint wraps the function in a CPS-converted HTTP request/response proxy that listens for POST requests on a given URL, expects a JSON array\nin the body, and converts the body into a list of parameters for the function you specify. Your function can access the reply continuation by either returning normally or invoking \'this\' on\nthe reply object.\n\nAll listeners are CPS-converted, so you can have coroutine-based communication between the client and server. For example, this is a broadcast chat server (which relies on singly re-entrant\ncontinuations for replies, if you want to think about it as a regular procedure call):\n\n| var clients = seq[~[]];\n  caterwaul.montenegro.server(8080) /se[_.rpc(\'/chat\',      fn_[clients.push(this)]).\n                                          rpc(\'/chat/send\', fn[message][seq[clients *![_(message)]], clients = seq[~[]], this(\'OK\')])];\n\nThe client code for this example is in montenegro.client.js.sdoc.\n\nRPC services can provide documentation. This is an optional second parameter, e.g:\n\n| chat_service.rpc(\'/chat\', \'Clients should long-loop this URL to be notified of messages that are sent.\', fn_[...]);\n\nAny clients who GET the URL will be served the documentation string as plain text. If you don\'t specify any documentation, GET requests will be sent a generic \'there\'s a service here, but no\ndocumentation for it\' message as plain text. The service will also send potentially useful diagnostic messages with 400 error codes if you\'re using it incorrectly.\n\n  tconfiguration(\'std continuation\', \'montenegro.server.rpc\', function () {\n    let*[json_from(request, rpc)(cc) = request /se[_.on(\'data\', pieces/mb/push), _.on(\'end\', fn_[unwind_protect[rpc.error(e)][cc(JSON.parse(pieces.join(\'\')))]]), where[pieces = []]],\n         json_to  (response)()  = let[as = Array.prototype.slice.call(arguments)] in response /se[_.writeHead(200, {\'content-type\': \'application/json\'}), _.end(JSON.stringify(as))],\n         error_to (response)(e) = response /se[_.writeHead(400, {\'content-type\': \'text/plain\'}), _.end(e.toString())],\n\n         install_service(url, doc, fn, rpc) = this /se[_.on(url, \'POST\', fn[req, res][json_from(req, rpc)(fn[json][fn.apply(json_to(res), json)])]),\n                                                       _.on(url, \'GET\',  fn[req, res][res /se[_.writeHead(200, {\'content-type\': \'text/plain\'}), _.end(doc)]])],\n\n         install_test_page(url, rpc) = this /se[_.on(\'#{url}/test\', \'GET\', fn[req, res][res /se[_.writeHead(200, {\'content-type\': \'text/html\'}), _.end(rpc.testpage())]])],\n\n         html = this.configure(\'montenegro.html\').montenegro.html] in\n\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se[\n      _.rpc(url, _documentation, _fn) = (install_service.call(this, url, documentation, fn, _.rpc), install_test_page.call(this, url, _.rpc),\n                                         where[documentation = _fn ? _documentation : \'#{url} service (no documentation available)\', fn = _fn || _documentation]),\n\n  Error trapping.\n  If an error occurs, the client receives the toString() produced by the error object and a stack trace is logged to the console. However, you may want to do something different. If you do,\n  change montenegro.server.rpc.error(e).\n\n      _.rpc.error(e) = e /se[console.log(_)],\n\n  Test pages.\n  If you use the server as shown above, you\'ll get a test page for each RPC endpoint. For example, the test page for the \'/chat\' URL is \'/chat/test\'. You can navigate to this page and send\n  requests to the RPC to verify that it\'s working correctly. This is enabled in production-mode as well as development mode; it\'s my attempt to encode Kerckhoffs\' principle\n  (http://en.wikipedia.org/wiki/Kerckhoffs\'_principle) into the framework to prevent bad security decisions.\n\n      _.rpc.testpage() = html(qs[$(\'head\').append(html[link /attr(\'rel\', \'stylesheet\') /attr(\'href\', \'http://fonts.googleapis.com/css?family=Droid+Sans+Mono&subset=latin\'),\n                                                       style(\'body {font-family: sans-serif; font-size: 9pt; width: 800px; margin: auto} a {color: #35a; cursor: pointer} .error {color: red} \',\n                                                             \'textarea {border: solid 1px #ccc; font-family: "Droid Sans Mono"; min-height: 200px; min-width: 800px} \',\n                                                             \'code {font-family: "Droid Sans Mono"} div.log {border-top: solid 1px #ccc; padding: 4px} .loading {color: #888}\')]),\n\n                                 $(\'body\').append(html[div > div.header(h1(\'RPC shell\'), h2.documentation(span.loading(\'loading documentation...\')))\n                                                           > p(\'You can evaluate code below. \', code(\'rpc()\'), \' is the RPC connector function for the API, and \', code(\'log()\'),\n                                                               \' can be used to log values. Your code will be macroexpanded under std, seq, opt, montenegro, and continuation.\')\n                                                           > div(button.run(\'Run\'))\n                                                           > textarea.code /val(\'let/cps[x <- rpc("Hello world", _)][log(x)]\')\n                                                           > div.log]),\n\n                                 window.rpc = caterwaul.montenegro.rpc(url),\n                                 $(\'.run\').click(fn_[unwind_protect[error(e)][caterwaul.clone(\'std seq continuation opt montenegro\')(\'(function () {#{$("textarea.code").val()}})\')()]]),\n                                 $.get(url, fn[doc][$(\'.documentation\').empty().append(doc)]),\n\n                                 where*[entry(x) = html[div.entry(code(x), \' \', a(\'[x]\')/click(fn_[$(this).parent().remove()]))],\n                                        log      = window.log(x)   = $(\'div.log\').append(entry(JSON.stringify(x))),\n                                        error    = window.error(x) = $(\'div.log\').append(entry(x.toString()).addClass(\'error\')),\n                                        url      = document.location.href.replace(/\\/test$/, \'\')]])]}).\n\nHTML server configuration.\nYou can send HTML pages to the client by writing initialization functions. To send a hello world page, for example:\n\n| montenegro.server(8080).html(\'/hello\', qs[$(\'body\').append(html[h1(\'Hello world!\')])]);\n\nThe client file contains full documentation for the html[] macro (the client ends up macroexpanding the code above).\n\n  tconfiguration(\'std\', \'montenegro.server.html\', function () {\n    let[html = this.configure(\'montenegro.html\').montenegro.html] in\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se[\n      _.html(url, t) = let[s = html(t)] in this /se[_.on(url, \'GET\', fn[req, res][res /se[_.writeHead(200, {\'content-type\': \'text/html\'}), _.end(s)]])]]}).\n\nProxy configuration.\nForwards headers both ways, changing only the \'host\' header for sending. You can specify functions to intercept the request/response data to transform it in some way.\n\n  tconfiguration(\'std seq continuation\', \'montenegro.server.proxy\', function () {\n    l[http = this.configure(\'montenegro.core\').montenegro.require(\'http\')] in\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se[\n      _.proxy(url, options) = l[options = caterwaul.util.merge({request_transform: fn[request][request], response_transform: fn[response][response]}, options)] in\n                              this /se[_.on(new RegExp(\'^#{url}\'), null, fn[req, res][\n                                l*[parts = /^\\/?([^:\\/]+)(:?\\d*)(\\/?.*)$/.exec(req.url.replace(url, \'\')), host = parts && parts[1], port = parts && Number(parts[2]) || 80,\n                                   req0  = options.request_transform(http.createClient(port, host).request(req.method, parts && parts[3] || \'/\', req.headers /se[_.host = host]))] in\n                                req0 /se[_.on(\'response\', _) /cps[_.setEncoding(\'binary\'), options.response_transform(_) /se[\n                                                                    res.writeHead(_.statusCode, _.headers), _.on(\'data\', _) /cps[res.write(_, \'binary\')], _.on(\'end\', _) /cps[res.end()]]],\n                                         req.on(\'data\', _) /cps.data[_.write(data, \'binary\')],\n                                         req.on(\'end\', _)  /cps.x[_.end()]]])]]}).\n\nFile server configuration.\nSometimes you want to serve files from a directory. This is a fairly simple service to do that. I imagine there are security problems with it.\n\n  tconfiguration(\'std continuation\', \'montenegro.server.file\', function () {\n    let[sanitize(s) = s.replace(/\\.\\+/g, \'.\'), fs = this.configure(\'montenegro.core\').montenegro.require(\'fs\')] in\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se.e[\n      e.file_extension_mimetypes = {css: \'text/css\', html: \'text/html\', js: \'application/javascript\', \'\': \'text/plain\'},\n      e.file(url, filename) = this /se[let/cps[(req, res)  <- this.on(new RegExp(\'^#{url.replace(/\\/$/, "")}(/|$)\'), \'GET\', _),\n                                               (err, data) <- fs.readFile(\'#{filename}#{sanitize(req.url.substring(url.length))}\', \'binary\', _)]\n                                              [err ? res /se[_.writeHead(500), _.end(err.toString())] :\n                                                     res /se[_.writeHead(200, {\'content-type\': content_type_for(req.url)}), _.write(data, \'binary\'), _.end()],\n                                               where[content_type_for(url) = /\\.(\\w+)$/.exec(url) /re[_ && _[1] /re[e.file_extension_mimetypes[_] || e.file_extension_mimetypes[\'\']]]]]]]}).\n\nAlias configuration.\nGives you the ability to alias content with or without redirects. For example:\n\n| some_server.alias(\'/\', \'/index.html\');                        // A server-side redirect (no 30x return code)\n  some_server.alias(\'/foo\', \'/bar\', \'POST\');                    // Alias POST requests instead of GETs\n  some_server.redirect(\'/\', \'/index.html\');                     // A client-side redirect (301 error code)\n  some_server.redirect(\'/\', \'/index.html\', {code: 302});        // A client-side redirect with a custom code\n  some_server.redirect(\'/foo\', \'/bar\', {method: \'POST\'});       // Issue redirect for POSTs instaed of GETs\n\n  tconfiguration(\'std continuation\', \'montenegro.server.alias\', function () {\n    this.configure(\'montenegro.server\').montenegro.server.extensions /se[\n      _.alias(from, to, method)     = this /se[_.on(from, method || \'GET\', fn[req, res][_(req /se[_.url = to], res)])],\n      _.redirect(from, to, options) = let[options = options || {}] in let/cps[(req, res) <- this.on(from, options.method || \'GET\', _)]\n                                                                             [res.writeHead(options.code || 301, {location: to}), res.end()]]}).\n\nFinal configuration.\nThis configuration bundles all of the configurations together.\n\n  configuration(\'montenegro\', function () {this.configure(\'montenegro.html montenegro.route.url montenegro.server montenegro.server.rpc montenegro.server.html montenegro.server.file\',\n                                                          \'montenegro.server.alias montenegro.server.proxy montenegro.global-error\')});\n');