sdocp('montenegro.jquery.js.sdoc', 'Client-side Montenegro/jQuery bindings | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nMontenegro works with jQuery to add structure to user interfaces and define useful shorthands for common cases. It also provides a Javascript markup language that you can use to build\ninterfaces instead of going the HTML route. For logic-heavy applications this may make more sense than separating the layout.\n\n  montenegro = caterwaul.configuration(\'montenegro.jquery.core\', function () {this.shallow(\'montenegro\', {jquery: {$: jQuery}})}).\n\nDOM construction.\nYou can build elements using a CSS-selector-style syntax. (Alternatively, you can provide an element in the markup; if you do it this way, the template element\'s ID should match the model\nname.) So, for example, suppose we\'re modeling a person with a name and e-mail address. Here\'s what the markup might look like in HTML:\n\n| <div id=\'person\' class=\'person\'>\n    <input class=\'name nonempty\' />\n    <input class=\'email\' />\n    <a class=\'facebook\' href=\'http://facebook.com/someone\'>A Facebook Page</a>\n  </div>\n\nHere\'s what it looks like using Montenegro markup syntax (triggered with the html<< operator):\n\n| html<< div.person[input.name.nonempty, input.email, a.facebook(href=\'http://facebook.com/someone\')[\'A Facebook Page\']]\n\n  Automation and event handlers.\n  You can get the jQuery shell for an element by using the \'/\' operator. The right-hand side is an invocation on the jQuery shell; for example:\n\n  | $(\'<a>\').addClass(\'foo\').click(fn_[...]).mouseover(fn_[...])\n    // can be written as:\n    html<< a.foo/click(fn_[...]).mouseover(fn_[...])\n\n  Anything after a \'/\' for an element is not considered to be HTML, so you\'ll have to use another html<< if you want to create elements to pass into a jQuery function. For example:\n\n  | html<< a.foo/append(span[\'some text\'])              // won\'t do what you want\n    html<< a.foo/append(html<< span[\'some text\'])       // this is the right way to do it\n\n  Evaluating subexpressions.\n  Going back to the person example, suppose you have a list of people that you want to insert into a div. Here\'s what that looks like:\n\n  | var people = sa<< [...];\n    var person = fn[p][html<< div.person[input.name.nonempty/val(p.name)]];\n    var ui     = html<< div.people[!people.map(person), button.save[\'Save\'], button.cancel[\'Cancel\']];\n\n  Here, the expression \'people.map(person)\' gets evaluated as a Javascript expression rather than as markup. The expression should return a string, sequence, array, or jQuery object.\n\n  Generalized side-effects.\n  Montenegro adds an \'se\' method to jQuery shells to allow you to perform generalized side-effects. For example:\n\n  | html<< div.foo/se(fn_[this.side_effect(), this.other_side_effect()])\n\n  The se() method passes the its jQuery object into the side-effecting function (both as \'this\' and as the first parameter) and returns the original jQuery object (which will be unmodified\n  unless the function explicitly mutates it; importantly, though, the function can use find() and such without modifying the outer state stack).\n\n  Mapping.\n  You can map an element through a function using the \'%\' shorthand. For example:\n\n  | var nonempty = fn_[this.instavalidate(/^.+$/)];\n    var ui = html<< div[input.name%nonempty, input.title%nonempty]\n\n  This isn\'t quite the same thing as side-effecting. Using the map shorthand replaces the element with whatever your map function returns, which may or may not be desirable (if it isn\'t, you\n  should probably use /se(...) instead -- see \'Generalized side-effects\').\n\n  Note that tempting as it is, you can\'t say this:\n\n  | html<< div[(input.name, input.title)%nonempty]      // can\'t do this, even though it would be awesome\n\n  I considered adding a distributive property, but Javascript\'s syntax is restrictive enough that I don\'t think it makes sense. It also makes you think too hard about your markup, which isn\'t\n  a good thing. The markup should be simple and local, and your modifier functions should be short enough to type several times. (This can be achieved by using a let-binding or similar.)\n\n    tconfiguration(\'std seq\', \'montenegro.jquery.dom\', function () {var jquery = this.configure(\'montenegro.jquery\').montenegro.jquery, $ = jquery.$;\n      jquery.create_node(tag)    = $(document.createElement(tag));\n      jquery.append(node, child) = child.force ? ((node.append(x) <sm< child).force(), node) : child.constructor === String ? node.append(document.createTextNode(child)) : node.append(child);\n\n      this.rmacro(qs[ html<< _], fn[expression][null]);         // TODO\n    }).\n\nFinal configuration.\nThis one loads all of the others. Keep in mind that you can also just use \'montenegro\' instead of \'caterwaul\' to get this configuration.\n\n  configuration(\'montenegro.jquery\', function () {this.configure(\'montenegro.jquery.core montenegro.jquery.dom\')}).clone(\'montenegro.jquery\');\n');